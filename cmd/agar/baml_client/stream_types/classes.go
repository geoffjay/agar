// ----------------------------------------------------------------------------
//
//  Welcome to Baml! To use this generated code, please run the following:
//
//  $ go get github.com/boundaryml/baml
//
// ----------------------------------------------------------------------------

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ go install github.com/boundaryml/baml/baml-cli

package stream_types

import (
	"fmt"

	baml "github.com/boundaryml/baml/engine/language_client_go/pkg"
	"github.com/boundaryml/baml/engine/language_client_go/pkg/cffi"
)

type AgarAppConfig struct {
	Name           *string           `json:"name"`
	Description    *string           `json:"description"`
	Module_path    *string           `json:"module_path"`
	Tools          []ToolConfig      `json:"tools"`
	Components     []ComponentConfig `json:"components"`
	Features       []string          `json:"features"`
	Main_structure *MainStructure    `json:"main_structure"`
}

func (c *AgarAppConfig) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "AgarAppConfig" {
		panic(fmt.Sprintf("expected AgarAppConfig, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "name":
			c.Name = baml.Decode(valueHolder).Interface().(*string)

		case "description":
			c.Description = baml.Decode(valueHolder).Interface().(*string)

		case "module_path":
			c.Module_path = baml.Decode(valueHolder).Interface().(*string)

		case "tools":
			c.Tools = baml.Decode(valueHolder).Interface().([]ToolConfig)

		case "components":
			c.Components = baml.Decode(valueHolder).Interface().([]ComponentConfig)

		case "features":
			c.Features = baml.Decode(valueHolder).Interface().([]string)

		case "main_structure":
			c.Main_structure = baml.Decode(valueHolder).Interface().(*MainStructure)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class AgarAppConfig", key))

		}
	}

}

func (c AgarAppConfig) Encode() (*cffi.CFFIValueHolder, error) {
	fields := map[string]any{}

	fields["name"] = c.Name

	fields["description"] = c.Description

	fields["module_path"] = c.Module_path

	fields["tools"] = c.Tools

	fields["components"] = c.Components

	fields["features"] = c.Features

	fields["main_structure"] = c.Main_structure

	return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c AgarAppConfig) BamlTypeName() string {
	return "AgarAppConfig"
}

func (u AgarAppConfig) BamlEncodeName() *cffi.CFFITypeName {
	return &cffi.CFFITypeName{
		Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
		Name:      "AgarAppConfig",
	}
}

type ComponentConfig struct {
	Type   *string `json:"type"`
	Name   *string `json:"name"`
	Config *string `json:"config"`
}

func (c *ComponentConfig) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ComponentConfig" {
		panic(fmt.Sprintf("expected ComponentConfig, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "type":
			c.Type = baml.Decode(valueHolder).Interface().(*string)

		case "name":
			c.Name = baml.Decode(valueHolder).Interface().(*string)

		case "config":
			c.Config = baml.Decode(valueHolder).Interface().(*string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class ComponentConfig", key))

		}
	}

}

func (c ComponentConfig) Encode() (*cffi.CFFIValueHolder, error) {
	fields := map[string]any{}

	fields["type"] = c.Type

	fields["name"] = c.Name

	fields["config"] = c.Config

	return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c ComponentConfig) BamlTypeName() string {
	return "ComponentConfig"
}

func (u ComponentConfig) BamlEncodeName() *cffi.CFFITypeName {
	return &cffi.CFFITypeName{
		Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
		Name:      "ComponentConfig",
	}
}

type FileSpec struct {
	Path    *string `json:"path"`
	Content *string `json:"content"`
	Purpose *string `json:"purpose"`
}

func (c *FileSpec) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "FileSpec" {
		panic(fmt.Sprintf("expected FileSpec, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "path":
			c.Path = baml.Decode(valueHolder).Interface().(*string)

		case "content":
			c.Content = baml.Decode(valueHolder).Interface().(*string)

		case "purpose":
			c.Purpose = baml.Decode(valueHolder).Interface().(*string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class FileSpec", key))

		}
	}

}

func (c FileSpec) Encode() (*cffi.CFFIValueHolder, error) {
	fields := map[string]any{}

	fields["path"] = c.Path

	fields["content"] = c.Content

	fields["purpose"] = c.Purpose

	return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c FileSpec) BamlTypeName() string {
	return "FileSpec"
}

func (u FileSpec) BamlEncodeName() *cffi.CFFITypeName {
	return &cffi.CFFITypeName{
		Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
		Name:      "FileSpec",
	}
}

type MainStructure struct {
	Use_tui        *bool    `json:"use_tui"`
	Entry_point    *string  `json:"entry_point"`
	Initialization []string `json:"initialization"`
}

func (c *MainStructure) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "MainStructure" {
		panic(fmt.Sprintf("expected MainStructure, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "use_tui":
			c.Use_tui = baml.Decode(valueHolder).Interface().(*bool)

		case "entry_point":
			c.Entry_point = baml.Decode(valueHolder).Interface().(*string)

		case "initialization":
			c.Initialization = baml.Decode(valueHolder).Interface().([]string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class MainStructure", key))

		}
	}

}

func (c MainStructure) Encode() (*cffi.CFFIValueHolder, error) {
	fields := map[string]any{}

	fields["use_tui"] = c.Use_tui

	fields["entry_point"] = c.Entry_point

	fields["initialization"] = c.Initialization

	return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c MainStructure) BamlTypeName() string {
	return "MainStructure"
}

func (u MainStructure) BamlEncodeName() *cffi.CFFITypeName {
	return &cffi.CFFITypeName{
		Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
		Name:      "MainStructure",
	}
}

type ProjectStructure struct {
	Directories  []string   `json:"directories"`
	Files        []FileSpec `json:"files"`
	Dependencies []string   `json:"dependencies"`
}

func (c *ProjectStructure) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ProjectStructure" {
		panic(fmt.Sprintf("expected ProjectStructure, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "directories":
			c.Directories = baml.Decode(valueHolder).Interface().([]string)

		case "files":
			c.Files = baml.Decode(valueHolder).Interface().([]FileSpec)

		case "dependencies":
			c.Dependencies = baml.Decode(valueHolder).Interface().([]string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class ProjectStructure", key))

		}
	}

}

func (c ProjectStructure) Encode() (*cffi.CFFIValueHolder, error) {
	fields := map[string]any{}

	fields["directories"] = c.Directories

	fields["files"] = c.Files

	fields["dependencies"] = c.Dependencies

	return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c ProjectStructure) BamlTypeName() string {
	return "ProjectStructure"
}

func (u ProjectStructure) BamlEncodeName() *cffi.CFFITypeName {
	return &cffi.CFFITypeName{
		Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
		Name:      "ProjectStructure",
	}
}

type ToolConfig struct {
	Name          *string `json:"name"`
	Purpose       *string `json:"purpose"`
	Custom_config *string `json:"custom_config"`
}

func (c *ToolConfig) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ToolConfig" {
		panic(fmt.Sprintf("expected ToolConfig, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "name":
			c.Name = baml.Decode(valueHolder).Interface().(*string)

		case "purpose":
			c.Purpose = baml.Decode(valueHolder).Interface().(*string)

		case "custom_config":
			c.Custom_config = baml.Decode(valueHolder).Interface().(*string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class ToolConfig", key))

		}
	}

}

func (c ToolConfig) Encode() (*cffi.CFFIValueHolder, error) {
	fields := map[string]any{}

	fields["name"] = c.Name

	fields["purpose"] = c.Purpose

	fields["custom_config"] = c.Custom_config

	return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c ToolConfig) BamlTypeName() string {
	return "ToolConfig"
}

func (u ToolConfig) BamlEncodeName() *cffi.CFFITypeName {
	return &cffi.CFFITypeName{
		Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
		Name:      "ToolConfig",
	}
}
